/*
 * This code was created based on information related to GCOV existing in
 * various places inside both GCC and the Linux kernel.
 *
 * Its main point is the CreateGCDAinMemory function; called from the
 * __gcov_exit hook at the end of execution. This function will generate
 * the .gcda files information in a memory buffer, which we then dump
 * to the host filesystem via GDB scripting.
 *
 * For information about the inner workings of this code, please study
 * GCC's gcov-io.{h,c} and then call me.
 *
 * Thanassis Tsiodras
 * Real-time Embedded Software Engineer
 * System, Software and Technology Department
 * European Space Agency
 * e-mail:
 *    Thanassis.Tsiodras@esa.int (work) 
 *    ttsiodras@gmail.com (Personal)
 */

#include "mini_rtl.h"
#include "gcov_internal.h"

#define GCOV_COUNTERS 5

/**
 * gcov_fn_info carries the profiling metadata per each function.
 *
 * @ident    : object file-unique function identifier
 * @checksum : function checksum
 * @n_ctrs   : number of values per counter type belonging to this function
 *
 * These are generated by GCC during compilation (due to the -fprofile-arcs
 * -ftest-coverage) and don't change at run-time.
 */
struct gcov_fn_info {
    unsigned int ident;
    unsigned int checksum;
    unsigned int n_ctrs[0];
};

/**
 * gcov_ctr_info carries the number and pointer to counted values
 * of each counter type.
 *
 * @num    : number of counter values for this type
 * @values : array of counter values for this type
 * @merge  : merge function for counter values of this type (not used here)
 *
 * These are generated by GCC during compilation (due to the -fprofile-arcs
 * -ftest-coverage) and don't change at run-time.
 */
struct gcov_ctr_info {
    unsigned int num;
    gcov_type *values;
    void (*merge)(gcov_type *, unsigned int);
};

/**
 * gcov_info carries the profiling data per each file compiled for coverage
 * (i.e. with -fprofile-arcs -ftest-coverage)
 *
 * @version     : gcov version magic indicating the gcc version used for compilation
 * @next        : list head for a singly-linked list
 * @stamp       : time stamp
 * @filename    : name of the associated gcov data file
 * @n_functions : number of instrumented functions
 * @functions   : function data
 * @ctr_mask    : mask specifying which counter types are active
 * @counts      : counter data per counter type
 *
 * These are generated by GCC during compilation (due to the -fprofile-arcs
 * -ftest-coverage) and don't change at run-time.
 */
struct gcov_info {
    unsigned int               version;
    struct gcov_info          *next;
    unsigned int               stamp;
    const char	              *filename;
    unsigned int               n_functions;
    const struct gcov_fn_info *functions;
    unsigned int               ctr_mask;
    struct gcov_ctr_info       counts[0];
};

/**
 * Internal prototypes - we use the iteration semantics inside GCC3.4
 */
static struct gcov_iterator *gcov_iter_new(struct gcov_info *info);
static void                  gcov_iter_start(struct   gcov_iterator *iter);
static int                   gcov_iter_next(struct    gcov_iterator *iter);
static unsigned              gcov_iter_write(struct   gcov_iterator *iter, unsigned pos, void *buffer);

/**
 * Which file was this gcov_info compiled for?
 */
const char *gcov_info_filename(struct gcov_info *info)
{
    return info->filename;
}

/**
 * Was this type of counter active in our GCOV data?
 * (compile-time data - unchanged at run-time)
 */
static int counter_active(struct gcov_info *info, unsigned int type)
{
    return (1 << type) & info->ctr_mask;
}

/**
 * How many active kinds of GCOV counters did we "burn" in during compilation?
 */
static unsigned int num_counter_active(struct gcov_info *info)
{
    unsigned int i;
    unsigned int result = 0;

    for (i = 0; i < GCOV_COUNTERS; i++) {
        if (counter_active(info, i))
            result++;
    }
    return result;
}

/**
 * Get the size of the function info entry - uses the 'array at end' pattern,
 * and the size depends on alignment... re-using the kernel macros for
 * proper alignment here.
 */
static unsigned get_fn_size(struct gcov_info *info)
{
    unsigned size;

    size = sizeof(struct gcov_fn_info) + \
        num_counter_active(info) * sizeof(unsigned int);

#ifndef ALIGN
#define __ALIGN_KERNEL_MASK(x, mask) (((x) + (mask)) & ~(mask))
#define __ALIGN_KERNEL(x, a)         __ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
#define ALIGN(x, a)                  __ALIGN_KERNEL((x), (a))

#endif
    if (__alignof__(struct gcov_fn_info) > sizeof(unsigned int))
        size = ALIGN(size, __alignof__(struct gcov_fn_info));
    return size;
}

/**
 * Get the address of a specific function info entry.
 * Due to alignment constraints, this can't just use N x sizeof.
 */
static struct gcov_fn_info *get_fn_info(struct gcov_info *info, unsigned int fn)
{
    return (struct gcov_fn_info *)
        ((char *) info->functions + fn * get_fn_size(info));
}

/**
 * The GCC3.4 arrangement in the compiled coverage information does
 * not align well with our needs for traversal during the generation
 * of the GCDA data. We re-use the iterator protocols in GCC3.4 here.
 *
 * @ctr_type : counter type
 * @offset   : index of the first value of the current function for this type
 *
 * The data are thus converted from this:
 *
 *   for each counter type
 *     for each function
 *       values
 *
 * To this:
 *
 *   for each function
 *     for each counter type
 *       values
 *
 * See gcc source gcc/gcov-io.h for more information on data organization.
 */
struct type_info {
    int ctr_type;
    unsigned int offset;
};

/**
 * gcov_iterator is used to iterate over the GCC-generated structures.
 *
 * @info      : associated profiling data
 * @record    : record type
 * @function  : function number
 * @type      : counter type
 * @count     : index into values array
 * @num_types : number of counter types
 * @type_info : helper structure to get values-array offset for current function
 */
struct gcov_iterator {
    struct gcov_info *info;
    int record;
    unsigned int function;
    unsigned int type;
    unsigned int count;
    unsigned num_types;
    struct type_info type_info[0];
};

/**
 * gcov_fn_info  returns the current function's coverage information
 * (i.e. the information for the function the iterator points to)
 */
static struct gcov_fn_info *get_func(struct gcov_iterator *iter)
{
    return get_fn_info(iter->info, iter->function);
}

/**
 * get_type returns the type data for the iterator's type
 * (most importantly, the counter offset to jump into)
 */
static struct type_info *get_type(struct gcov_iterator *iter)
{
    return &iter->type_info[iter->type];
}

/*
 * The iterator protocols re-used below are depending on a working heap.
 * That's not available under EDISOFT - so the "mini_rtl.c" offers
 * the simplest heap possible: one allocating from a buffer going
 * only forward, and a non-existing free.
 *
 * This is not an issue in our case, because this code will only be
 * executed at the end of the application - in the context of 
 * __gcov_exit.
 *
 * gcov_iter_new - allocate and initialize the iterator
 *
 * @info: profiling data set to be iterated over.
 *
 * Return file iterator on success, NULL otherwise.
 */
static struct gcov_iterator *gcov_iter_new(struct gcov_info *info)
{
    struct gcov_iterator *iter;

    iter = malloc(
        sizeof(struct gcov_iterator) +
        num_counter_active(info) * sizeof(struct type_info));
    if (iter)
        iter->info = info;
    return iter;
}

/**
 * gcov_iter_start - reset the coverage iterator
 */
static void gcov_iter_start(struct gcov_iterator *iter)
{
    int i;

    iter->record = 0;
    iter->function = 0;
    iter->type = 0;
    iter->count = 0;
    iter->num_types = 0;
    for (i = 0; i < GCOV_COUNTERS; i++) {
        if (counter_active(iter->info, i)) {
            iter->type_info[iter->num_types].ctr_type = i;
            iter->type_info[iter->num_types++].offset = 0;
        }
    }
}

/* Mapping of logical record number to actual GCDA file content. */
#define RECORD_FILE_MAGIC	0
#define RECORD_GCOV_VERSION	1
#define RECORD_TIME_STAMP	2
#define RECORD_FUNCTION_TAG	3
#define RECORD_FUNCTON_TAG_LEN	4
#define RECORD_FUNCTION_IDENT	5
#define RECORD_FUNCTION_CHECK	6
#define RECORD_COUNT_TAG	7
#define RECORD_COUNT_LEN	8
#define RECORD_COUNT		9

/**
 * gcov_iter_next - advance the iterator to the next logical record
 *
 * @iter: iterator
 *
 * Return zero if new position is valid, non-zero if iterator has concluded.
 */
static int gcov_iter_next(struct gcov_iterator *iter)
{
    switch (iter->record) {
        case RECORD_FILE_MAGIC:
        case RECORD_GCOV_VERSION:
        case RECORD_FUNCTION_TAG:
        case RECORD_FUNCTON_TAG_LEN:
        case RECORD_FUNCTION_IDENT:
        case RECORD_COUNT_TAG:
            /* Advance to next record */
            iter->record++;
            break;
        case RECORD_COUNT:
            /* Advance to next count */
            iter->count++;
            /* fall through */
        case RECORD_COUNT_LEN:
            if (iter->count < get_func(iter)->n_ctrs[iter->type]) {
                iter->record = 9;
                break;
            }
            /* Advance to next counter type */
            get_type(iter)->offset += iter->count;
            iter->count = 0;
            iter->type++;
            /* fall through */
        case RECORD_FUNCTION_CHECK:
            if (iter->type < iter->num_types) {
                iter->record = 7;
                break;
            }
            /* Advance to next function */
            iter->type = 0;
            iter->function++;
            /* fall through */
        case RECORD_TIME_STAMP:
            if (iter->function < iter->info->n_functions)
                iter->record = 3;
            else
                iter->record = -1;
            break;
    }
    /* Did we unexpectedly run out of records? */
    if (iter->record == -1)
        // Avoid including system files - EDISOFT is really sensitive on this,
        // and the code must work for OAR, EDISOFT and LINUX!
        //
        // return -EINVAL;
        return -22;
    else
        return 0;
}

/**
 * gcov_iter_write - write data for current iterator to memory buffer
 *
 * @iter   : file iterator
 * @pos    : current buffer position
 * @buffer : buffer used to store GCDA content
 *
 * Return the current amount of bytes in the buffer.
 */
static unsigned gcov_iter_write(struct gcov_iterator *iter, unsigned pos, void *buffer)
{
    switch (iter->record) {
        case RECORD_FILE_MAGIC:
            pos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);
            break;
        case RECORD_GCOV_VERSION:
            pos += store_gcov_u32(buffer, pos, iter->info->version);
            break;
        case RECORD_TIME_STAMP:
            pos += store_gcov_u32(buffer, pos, iter->info->stamp);
            break;
        case RECORD_FUNCTION_TAG:
            pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);
            break;
        case RECORD_FUNCTON_TAG_LEN:
            pos += store_gcov_u32(buffer, pos, 2);
            break;
        case RECORD_FUNCTION_IDENT:
            pos += store_gcov_u32(buffer, pos, get_func(iter)->ident);
            break;
        case RECORD_FUNCTION_CHECK:
            pos += store_gcov_u32(buffer, pos, get_func(iter)->checksum);
            break;
        case RECORD_COUNT_TAG:
            pos += store_gcov_u32(buffer, pos, GCOV_TAG_FOR_COUNTER(get_type(iter)->ctr_type));
            break;
        case RECORD_COUNT_LEN:
            pos += store_gcov_u32(buffer, pos, get_func(iter)->n_ctrs[iter->type] * 2);
            break;
        case RECORD_COUNT:
            pos += store_gcov_u64(buffer, pos, iter->info->counts[iter->type].
                    values[iter->count + get_type(iter)->offset]);
            break;
    }
    return pos;
}

/**
 * CreateGCDAinMemory - convert profiling data set to gcda file format
 *
 * @buffer : the buffer to store file data or NULL if just counting
 * @info   : profiling data set to be converted
 *
 * Returns the number of bytes that were/would have been stored in the buffer.
 */
unsigned CreateGCDAinMemory(char *buffer, struct gcov_info *info)
{
    unsigned pos = 0;

    struct gcov_iterator *it = gcov_iter_new(info);
    gcov_iter_start(it);
    do {
        pos = gcov_iter_write(it, pos, buffer);
    } while(!gcov_iter_next(it));
    return pos;
}
