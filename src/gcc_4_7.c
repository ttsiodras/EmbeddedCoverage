/*
 * This code was created based on information related to GCOV existing in
 * various places inside both GCC and the Linux kernel.
 *
 * Its main point is the CreateGCDAinMemory function; called from the
 * __gcov_exit hook at the end of execution. This function will generate
 * the .gcda files information in a memory buffer, which we then dump
 * to the host filesystem via GDB scripting.
 *
 * For information about the inner workings of this code, please study
 * GCC's gcov-io.{h,c} and then call me.
 *
 * Thanassis Tsiodras
 * Real-time Embedded Software Engineer
 * System, Software and Technology Department
 * European Space Agency
 * e-mail:
 *    Thanassis.Tsiodras@esa.int (work) 
 *    ttsiodras@gmail.com (Personal)
 */

#include "gcov_internal.h"

#ifndef EDISOFT
#include <stdlib.h>
#include <memory.h>
#endif

#if __GNUC__ == 4 && __GNUC_MINOR__ >= 9
#define GCOV_COUNTERS 9
#else
#define GCOV_COUNTERS 8
#endif

#define GCOV_TAG_FUNCTION_LENGTH 3

/**
 * gcov_ctr_info carries the number and pointer to counted values
 * of each counter type.
 *
 * @num    : number of counter values for this type
 * @values : array of counter values for this type
 *
 * These are generated by GCC during compilation (due to the -fprofile-arcs
 * -ftest-coverage) and don't change at run-time.
 */
struct gcov_ctr_info {
    unsigned int num;
    gcov_type *values;
};

/**
 * gcov_fn_info carries the profiling metadata per each function.
 *
 * @key             : comdat key
 * @ident           : unique ident of function
 * @lineno_checksum : function lineo_checksum
 * @cfg_checksum    : function cfg checksum
 * @ctrs            : instrumented counters
 *
 * These are generated by GCC during compilation (due to the -fprofile-arcs
 * -ftest-coverage) and don't change at run-time.
 * struct gcov_fn_info - profiling meta data per function
 */
struct gcov_fn_info {
    const struct gcov_info *key;
    unsigned int ident;
    unsigned int lineno_checksum;
    unsigned int cfg_checksum;
    struct gcov_ctr_info ctrs[0];
};

/**
 * gcov_info carries the profiling data per each file compiled for coverage
 * (i.e. with -fprofile-arcs -ftest-coverage)
 *
 * @version     : gcov version magic (gcc version used for compilation)
 * @next        : list head for a singly-linked list
 * @stamp       : uniquifying time stamp
 * @filename    : name of the associated gcov data file
 * @merge       : merge functions (null for unused counter type)
 * @n_functions : number of instrumented functions
 * @functions   : pointer to pointers to function information
 *
 * These are generated by GCC during compilation (due to the -fprofile-arcs
 * -ftest-coverage) and don't change at run-time.
 */
struct gcov_info {
    unsigned int version;
    struct gcov_info *next;
    unsigned int stamp;
    const char *filename;
    void (*merge[GCOV_COUNTERS])(gcov_type *, unsigned int);
    unsigned int n_functions;
    struct gcov_fn_info **functions;
};

/**
 * Was this type of counter active in our GCOV data?
 * (compile-time data - unchanged at run-time)
 */
static int counter_active(struct gcov_info *info, unsigned int type)
{
    return info->merge[type] ? 1 : 0;
}

/**
 * Which file was this gcov_info compiled for?
 */
const char *gcov_info_filename(struct gcov_info *info)
{
    return info->filename;
}

/**
 * CreateGCDAinMemory - convert profiling data set to gcda file format
 *
 * @buffer : the buffer to store file data or NULL if just counting
 * @info   : profiling data set to be converted
 *
 * Returns the number of bytes that were/would have been stored in the buffer.
 */
unsigned CreateGCDAinMemory(char *buffer, struct gcov_info *info)
{
    struct gcov_fn_info *fi_ptr;
    struct gcov_ctr_info *ci_ptr;
    unsigned int fi_idx;
    unsigned int ct_idx;
    unsigned int cv_idx;
    unsigned pos = 0;

    /* GCDA File header. */
    pos += store_gcov_u32(buffer, pos, GCOV_DATA_MAGIC);
    pos += store_gcov_u32(buffer, pos, info->version);
    pos += store_gcov_u32(buffer, pos, info->stamp);

    /* For each function... */
    for (fi_idx = 0; fi_idx < info->n_functions; fi_idx++) {
        fi_ptr = info->functions[fi_idx];

        /* Emit a function record */
        pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION);
        pos += store_gcov_u32(buffer, pos, GCOV_TAG_FUNCTION_LENGTH);
        pos += store_gcov_u32(buffer, pos, fi_ptr->ident);
        pos += store_gcov_u32(buffer, pos, fi_ptr->lineno_checksum);
        pos += store_gcov_u32(buffer, pos, fi_ptr->cfg_checksum);

        /* and for each kind of counter in the function... */
        for (ci_ptr = fi_ptr->ctrs, ct_idx = 0;
             ct_idx < GCOV_COUNTERS;
             ct_idx++)
        {
            if (!counter_active(info, ct_idx))
                continue;

            /* emit a counter record with all values of this counter's kind */
            pos += store_gcov_u32(buffer, pos, GCOV_TAG_FOR_COUNTER(ct_idx));
            pos += store_gcov_u32(buffer, pos, ci_ptr->num * 2);

            for (cv_idx = 0; cv_idx < ci_ptr->num; cv_idx++) {
                pos += store_gcov_u64(buffer, pos, ci_ptr->values[cv_idx]);
            }
            ci_ptr++;
        }
    }
    return pos;
}
